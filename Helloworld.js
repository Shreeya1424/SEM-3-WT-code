orithms:

1. What is the worst-case time complexity of Linear Search?
A. O(log n)
B. O(n)
C. O(n log n)
D. O(1)
Answer: B. O(n)
2. Which search algorithm requires a sorted array to function correctly?
A. Linear Search
B. Binary Search
C. Brute-force Search
D. Depth-first Search
Answer: B. Binary Search
3. What is the best-case time complexity of Binary Search?
A. O(1)
B. O(n)
C. O(log n)
D. O(n²)
Answer: A. O(1)
4. In Binary Search, if the middle element is greater than the key, which part of the array is searched next?
A. Left half
B. Right half
C. Middle part
D. None
Answer: A. Left half
5. What is the time complexity of Bubble Sort in the worst case?
A. O(n log n)
B. O(n²)
C. O(n)
D. O(log n)
Answer: B. O(n²)
6. Which sorting algorithm is efficient for nearly sorted lists?
A. Selection Sort
B. Bubble Sort
C. Insertion Sort
D. Quick Sort
Answer: C. Insertion Sort
7. What is the characteristic of Selection Sort regarding its stability?
A. It is stable
B. It is not stable
C. Stability depends on implementation
D. It uses extra memory to maintain stability
Answer: B. It is not stable
8. Which algorithm is based on the divide-and-conquer approach?
A. Linear Search
B. Quick Sort
C. Bubble Sort
D. Selection Sort
Answer: B. Quick Sort
9. In Heap Sort, which data structure is used?
A. Stack
B. Queue
C. Binary Heap
D. Linked List
Answer: C. Binary Heap
10. Which of the following algorithms is not comparison-based?
A. Quick Sort
B. Merge Sort
C. Counting Sort
D. Selection Sort
Answer: C. Counting Sort
11. What is the space complexity of Counting Sort?
A. O(1)
B. O(n)
C. O(n + k)
D. O(log n)
Answer: C. O(n + k)
12. What does Radix Sort rely on for sorting?
A. Heap Data Structure
B. Merging Technique
C. Digit by digit processing
D. Pivot element
Answer: C. Digit by digit processing
13. Which sorting algorithm is known as a stable algorithm?
A. Quick Sort
B. Heap Sort
C. Bubble Sort
D. Selection Sort
Answer: C. Bubble Sort
14. What is the main advantage of Merge Sort?
A. Best time complexity of O(n²)
B. It is stable and works well with large datasets
C. Requires no additional memory
D. Works only with sorted arrays
Answer: B. It is stable and works well with large datasets
15. What is the primary disadvantage of using Quick Sort?
A. Uses extra space
B. Worst-case time complexity is O(n²)
C. Inefficient for small datasets
D. Cannot be parallelized
Answer: B. Worst-case time complexity is O(n²)
16. What type of algorithm is Shell Sort?
A. Divide-and-conquer
B. In-place sorting
C. Recursive
D. Non-comparison based
Answer: B. In-place sorting
17. Which sorting algorithm works by repeatedly swapping adjacent elements if they are in the wrong order?
A. Selection Sort
B. Merge Sort
C. Bubble Sort
D. Radix Sort
Answer: C. Bubble Sort
18. What is the time complexity of Quick Sort in the average case?
A. O(n)
B. O(log n)
C. O(n log n)
D. O(n²)
Answer: C. O(n log n)
19. Which of the following sorting algorithms is not stable by default?
A. Merge Sort
B. Quick Sort
C. Insertion Sort
D. Bubble Sort
Answer: B. Quick Sort
20. Which sorting algorithm uses a pivot element to partition the array?
A. Selection Sort
B. Quick Sort
C. Merge Sort
D. Insertion Sort
Answer: B. Quick Sort
21. What is the time complexity of Merge Sort in the worst case?
A. O(n log n)
B. O(n²)
C. O(n)
D. O(log n)
Answer: A. O(n log n)
22. In which sorting algorithm are elements divided into buckets and then sorted individually?
A. Quick Sort
B. Merge Sort
C. Bucket Sort
D. Heap Sort
Answer: C. Bucket Sort
23. What type of heap is used in Heap Sort to arrange elements in ascending order?
A. Min Heap
B. Max Heap
C. Fibonacci Heap
D. Binary Search Tree
Answer: B. Max Heap
24. Which algorithm is generally faster for large data sets?
A. Selection Sort
B. Quick Sort
C. Bubble Sort
D. Counting Sort
Answer: B. Quick Sort
25. What is the key characteristic of a stable sorting algorithm?
A. It sorts the elements using binary trees
B. It maintains the relative order of records with equal keys
C. It requires O(n log n) time
D. It uses a pivot element
Answer: B. It maintains the relative order of records with equal keys
26. Which sorting algorithm can work in O(n) time for certain data distributions?
A. Merge Sort
B. Quick Sort
C. Counting Sort
D. Insertion Sort
Answer: C. Counting Sort
27. What is the worst-case time complexity of Selection Sort?
A. O(log n)
B. O(n²)
C. O(n log n)
D. O(n)
Answer: B. O(n²)
28. In which sorting algorithm does each pass ensure that the largest unsorted element is placed at its correct position?
A. Insertion Sort
B. Selection Sort
C. Bubble Sort
D. Merge Sort
Answer: C. Bubble Sort
29. What is the advantage of the Insertion Sort algorithm?
A. High efficiency for large datasets
B. Simple implementation and works well on small or nearly sorted data
C. Worst-case time complexity is O(n)
D. No need for additional memory
Answer: B. Simple implementation and works well on small or nearly sorted data
30. What does the time complexity O(n log n) typically indicate for sorting algorithms?
A. Optimal efficiency for comparison-based sorts
B. Poor performance for small datasets
C. High space complexity
D. Unstable sorting algorithm
Answer: A. Optimal efficiency for comparison-based sorts
31. Which sorting algorithm is based on the idea of repeatedly dividing an unsorted list into smaller sublists?
A. Merge Sort
B. Selection Sort
C. Quick Sort
D. Bubble Sort
Answer: A. Merge Sort
32. What is the space complexity of Merge Sort?
A. O(n)
B. O(log n)
C. O(1)
D. O(n²)
Answer: A. O(n)
33. Which algorithm always ensures that the list is partially sorted at the end of each pass?
A. Quick Sort
B. Bubble Sort
C. Selection Sort
D. Insertion Sort
Answer: B. Bubble Sort
34. In a Binary Search, what is the key condition to continue searching the right half of the array?
A. Middle element is less than the search key
B. Middle element is greater than the search key
C. Middle element equals the search key
D. The search key is at the leftmost position
Answer: A. Middle element is less than the search key
35. Which sorting algorithm repeatedly selects the minimum element from the unsorted portion and places it at the beginning?
A. Bubble Sort
B. Quick Sort
C. Selection Sort
D. Merge Sort
Answer: C. Selection Sort
36. What is the best-case time complexity of Insertion Sort?
A. O(n log n)
B. O(n)
C. O(n²)
D. O(log n)
Answer: B. O(n)
37. Which of the following algorithms uses partitioning as its main operation?
A. Insertion Sort
B. Merge Sort
C. Quick Sort
D. Heap Sort
Answer: C. Quick Sort
38. Which sorting algorithm is especially efficient for sorting lists that are already nearly sorted?
A. Selection Sort
B. Bubble Sort
C. Quick Sort
D. Insertion Sort
Answer: D. Insertion Sort
39. How does Bucket Sort divide the elements of an array for sorting?
A. Into equally sized ranges
B. Using binary trees
C. Based on the pivot element
D. Randomly distributed buckets
Answer: A. Into equally sized ranges
40. What is the primary difference between Merge Sort and Quick Sort?
A. Merge Sort uses extra space, Quick Sort is in-place
B. Quick Sort is stable, Merge Sort is not
C. Merge Sort is faster than Quick Sort for large datasets
D. Merge Sort has a higher time complexity than Quick Sort
Answer: A. Merge Sort uses extra space, Quick Sort is in-place
41. Which of the following sorting algorithms has the best time complexity in the average case?
A. Quick Sort
B. Merge Sort
C. Bubble Sort
D. Selection Sort
Answer: A. Quick Sort
42. What is the main benefit of Counting Sort compared to comparison-based sorting algorithms?
A. Better time complexity for large input sizes
B. No need for additional memory
C. Can sort data in O(n) time
D. Works with all types of input data
Answer: C. Can sort data in O(n) time
43. Which search algorithm operates on both sorted and unsorted arrays?
A. Binary Search
B. Linear Search
C. Radix Search
D. Interpolation Search
Answer: B. Linear Search
44. Which algorithm involves “bubbling up” smaller elements to the start of the array?
A. Merge Sort
B. Selection Sort
C. Bubble Sort
D. Quick Sort
Answer: C. Bubble Sort
45. In Heap Sort, which index corresponds to the parent node of a child at index i in a max heap?
A. (i+1)/2
B. (i-1)/2
C. 2*i
D. 2*i + 1
Answer: B. (i-1)/2
46. Which of the following algorithms is a stable sorting algorithm?
A. Selection Sort
B. Heap Sort
C. Bubble Sort
D. Quick Sort
Answer: C. Bubble Sort
47. What is the time complexity of Heap Sort in the worst case?
A. O(n)
B. O(n log n)
C. O(log n)
D. O(n²)
Answer: B. O(n log n)
48. What type of data is best suited for Radix Sort?
A. Strings
B. Fixed-length numbers
C. Floating-point numbers
D. Large integers
Answer: B. Fixed-length numbers
49. Which sorting algorithm is preferred for its in-place operation and efficiency for large datasets?
A. Merge Sort
B. Quick Sort
C. Counting Sort
D. Radix Sort
Answer: B. Quick Sort
50. Which algorithm’s time complexity can improve to O(n) when sorting arrays that are nearly sorted?
A. Bubble Sort
B. Insertion Sort
C. Merge Sort
D. Quick Sort
Answer: B. Insertion Sort
51. In which case does Binary Search work efficiently?
A. With sorted arrays
B. With unsorted arrays
C. With linked lists
D. With non-numeric data
Answer: A. With sorted arrays
52. Which sorting algorithm does not require additional space for merging operations?
A. Merge Sort
B. Quick Sort
C. Radix Sort
D. Counting Sort
Answer: B. Quick Sort
53. Which sorting algorithm has a best-case time complexity of O(n²)?
A. Bubble Sort
B. Selection Sort
C. Insertion Sort
D. Shell Sort
Answer: B. Selection Sort
54. What is the primary benefit of the Quick Sort algorithm compared to Merge Sort?
A. Requires less additional memory
B. More stable
C. Faster in worst-case scenarios
D. It is a comparison-based algorithm
Answer: A. Requires less additional memory
55. What is the time complexity of Radix Sort for sorting numbers?
A. O(n log n)
B. O(n + k)
C. O(n²)
D. O(n * d)
Answer: D. O(n * d)
56. What is the worst-case time complexity of Bubble Sort?
A. O(n²)
B. O(n)
C. O(n log n)
D. O(n³)
Answer: A. O(n²)
57. How does Quick Sort partition an array?
A. By merging the smallest and largest elements
B. By dividing the array into two halves and sorting them
C. By selecting a pivot element and arranging smaller elements on one side and larger ones on the other
D. By repeatedly swapping adjacent elements
Answer: C. By selecting a pivot element and arranging smaller elements on one side and larger ones on the other
58. Which of the following is a non-comparison sorting algorithm?
A. Quick Sort
B. Merge Sort
C. Counting Sort
D. Selection Sort
Answer: C. Counting Sort
59. Which data structure is primarily used in Heap Sort?
A. Stack
B. Queue
C. Tree
D. Binary Heap
Answer: D. Binary Heap
60. What is the key difference between Insertion Sort and Selection Sort?
A. Insertion Sort works by inserting each element in its correct position; Selection Sort selects the smallest element and swaps it.
B. Insertion Sort requires more space; Selection Sort is in-place.
C. Selection Sort has better time complexity in the average case.
D. Insertion Sort is unstable; Selection Sort is stable.
Answer: A. Insertion Sort works by inserting each element in its correct position; Selection Sort selects the smallest element and swaps it.
61. Which sorting algorithm divides the list into sublists based on a gap value and then sorts the sublists?
A. Quick Sort
B. Shell Sort
C. Merge Sort
D. Radix Sort
Answer: B. Shell Sort
62. How is the time complexity of Counting Sort represented, where k is the range of the input?
A. O(n log k)
B. O(n + k)
C. O(n log n)
D. O(n²)
Answer: B. O(n + k)
63. Which sorting algorithm divides the unsorted list into N sublists, each containing one element?
A. Quick Sort
B. Merge Sort
C. Heap Sort
D. Radix Sort
Answer: B. Merge Sort
64. In Binary Search, what happens when the search key is larger than the middle element?
A. The search continues on the left half of the array
B. The search continues on the right half of the array
C. The search ends
D. The entire array is searched again
Answer: B. The search continues on the right half of the array
65. Which of the following is true about Merge Sort?
A. It is an in-place sorting algorithm
B. It requires additional space for merging
C. Its best-case time complexity is O(n²)
D. It is unstable
Answer: B. It requires additional space for merging
66. Which sorting algorithm uses pivoting to rearrange elements in an array?
A. Merge Sort
B. Selection Sort
C. Quick Sort
D. Insertion Sort
Answer: C. Quick Sort
67. What is the time complexity of Shell Sort in the average case?
A. O(n log n)
B. O(n²)
C. O(n)
D. O(n^1.5)
Answer: D. O(n^1.5)
68. Which sorting algorithm guarantees sorting with O(n log n) in all cases?
A. Quick Sort
B. Merge Sort
C. Insertion Sort
D. Selection Sort
Answer: B. Merge Sort
69. Which sorting algorithm sorts by processing each digit of the numbers individually?
A. Quick Sort
B. Radix Sort
C. Heap Sort
D. Selection Sort
Answer: B. Radix Sort
70. Which of the following statements about Quick Sort is true?
A. It requires O(n) additional memory
B. Its worst-case time complexity is O(n²)
C. It is not a comparison-based algorithm
D. It is stable by default
Answer: B. Its worst-case time complexity is O(n²)